# Rate Limiting Sistemi - Mevcut Durum ve Gelecek PlanÄ±

## ğŸ“Š Mevcut Durum Analizi

### ğŸ”§ Åu Anki KonfigÃ¼rasyon
```typescript
const RATE_LIMITS = {
  api: { limit: 100, window: 60 },        // 100 request/dakika
  auth: { limit: 5, window: 900 },        // 5 login/15 dakika  
  register: { limit: 3, window: 3600 },   // 3 kayÄ±t/saat
  email: { limit: 10, window: 3600 },     // 10 email/saat
  menu: { limit: 5000, window: 60 },      // 5000 menu view/dakika âœ… (artÄ±rÄ±ldÄ±)
  order: { limit: 50, window: 300 },      // 50 sipariÅŸ/5 dakika
};
```

### âš ï¸ Kritik Sorunlar

#### 1. **Menu Rate Limit YetersizliÄŸi** âœ… Ã‡Ã–ZÃœLDÃœ
- **Ã–nceki:** 1000 gÃ¶rÃ¼ntÃ¼lenme/dakika
- **Åu Anki:** 5000 gÃ¶rÃ¼ntÃ¼lenme/dakika (5x artÄ±rÄ±ldÄ±)
- **Durum:** GeÃ§ici Ã§Ã¶zÃ¼m uygulandÄ±, dinamik sistem planlanÄ±yor
- **Sonraki AdÄ±m:** Restoran bazlÄ± dinamik limitler

#### 2. **Sabit Limitler**
- TÃ¼m kullanÄ±cÄ±lar aynÄ± limitlere sahip
- Premium kullanÄ±cÄ±lar iÃ§in farklÄ±laÅŸtÄ±rma yok
- Restoran bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne gÃ¶re dinamik ayarlama yok

#### 3. **Basit Sliding Window**
- Redis'te basit `INCR` kullanÄ±mÄ±
- Distributed rate limiting iÃ§in yetersiz
- Burst traffic'i iyi handle etmiyor

## ğŸš€ Gelecek PlanÄ± - Ã–lÃ§eklenebilir Rate Limiting

### ğŸ“ˆ Faz 1: Dinamik Limit Sistemi (1-2 Hafta)

#### 1.1 Restoran BazlÄ± Limitler
```typescript
interface RestaurantRateLimits {
  small: { menu: 2000, order: 100 };      // 1-50 masa
  medium: { menu: 5000, order: 250 };     // 51-200 masa  
  large: { menu: 10000, order: 500 };     // 201+ masa
  enterprise: { menu: 25000, order: 1000 }; // Zincir restoranlar
}
```

#### 1.2 KullanÄ±cÄ± Tipleri
```typescript
interface UserRateLimits {
  anonymous: { menu: 100, order: 0 };     // QR tarayÄ±cÄ±lar
  registered: { menu: 1000, order: 50 };  // KayÄ±tlÄ± kullanÄ±cÄ±lar
  premium: { menu: 5000, order: 200 };    // Premium Ã¼yeler
  business: { menu: 10000, order: 500 };  // Ä°ÅŸ hesabÄ±
}
```

#### 1.3 Dinamik Limit Hesaplama
```typescript
async function calculateDynamicLimit(
  restaurantId: string,
  endpoint: string,
  userType: UserType
): Promise<RateLimitConfig> {
  const restaurant = await getRestaurant(restaurantId);
  const baseLimit = getBaseLimit(restaurant.size, endpoint);
  const userMultiplier = getUserMultiplier(userType);
  const timeMultiplier = getTimeMultiplier(); // Saat bazlÄ±
  
  return {
    limit: baseLimit * userMultiplier * timeMultiplier,
    window: getOptimalWindow(endpoint)
  };
}
```

### ğŸ”„ Faz 2: GeliÅŸmiÅŸ Rate Limiting AlgoritmalarÄ± (2-3 Hafta)

#### 2.1 Token Bucket Algorithm
```typescript
class TokenBucketRateLimiter {
  private tokens: Map<string, number>;
  private lastRefill: Map<string, number>;
  
  async consume(identifier: string, tokens: number): Promise<boolean> {
    const now = Date.now();
    const bucket = await this.getBucket(identifier);
    
    // Token'larÄ± yenile
    const timePassed = now - bucket.lastRefill;
    const tokensToAdd = Math.floor(timePassed / this.refillRate);
    bucket.tokens = Math.min(bucket.capacity, bucket.tokens + tokensToAdd);
    
    // Token tÃ¼ket
    if (bucket.tokens >= tokens) {
      bucket.tokens -= tokens;
      bucket.lastRefill = now;
      return true;
    }
    
    return false;
  }
}
```

#### 2.2 Leaky Bucket Algorithm
```typescript
class LeakyBucketRateLimiter {
  private buckets: Map<string, LeakyBucket>;
  
  async process(identifier: string): Promise<boolean> {
    const bucket = this.getBucket(identifier);
    const now = Date.now();
    
    // Bucket'tan sÄ±zan miktarÄ± hesapla
    const leaked = Math.floor((now - bucket.lastLeak) / bucket.leakRate);
    bucket.tokens = Math.max(0, bucket.tokens - leaked);
    
    if (bucket.tokens < bucket.capacity) {
      bucket.tokens++;
      bucket.lastLeak = now;
      return true;
    }
    
    return false;
  }
}
```

### ğŸŒ Faz 3: Distributed Rate Limiting (3-4 Hafta)

#### 3.1 Redis Cluster DesteÄŸi
```typescript
class DistributedRateLimiter {
  private redisCluster: Redis.Cluster;
  
  async checkRateLimit(
    key: string, 
    limit: number, 
    window: number
  ): Promise<RateLimitResult> {
    const script = `
      local current = redis.call('incr', KEYS[1])
      if current == 1 then
        redis.call('expire', KEYS[1], ARGV[1])
      end
      return {current, redis.call('ttl', KEYS[1])}
    `;
    
    const [current, ttl] = await this.redisCluster.eval(
      script, 1, key, window
    );
    
    return {
      allowed: current <= limit,
      remaining: Math.max(0, limit - current),
      resetTime: Date.now() + (ttl * 1000)
    };
  }
}
```

#### 3.2 Rate Limiting Proxy (Nginx/Cloudflare)
```nginx
# nginx.conf
http {
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=menu:10m rate=100r/s;
    
    server {
        location /api/ {
            limit_req zone=api burst=20 nodelay;
        }
        
        location /api/menu/ {
            limit_req zone=menu burst=200 nodelay;
        }
    }
}
```

### ğŸ“Š Faz 4: Monitoring ve Analytics (2-3 Hafta)

#### 4.1 Rate Limit Metrics
```typescript
interface RateLimitMetrics {
  endpoint: string;
  totalRequests: number;
  rateLimitedRequests: number;
  averageResponseTime: number;
  peakRequestsPerSecond: number;
  uniqueUsers: number;
  topBlockedIPs: string[];
}
```

#### 4.2 Real-time Dashboard
```typescript
class RateLimitMonitor {
  async getMetrics(timeframe: string): Promise<RateLimitMetrics[]> {
    const pipeline = redis.pipeline();
    
    // Ã‡eÅŸitli metrikleri paralel olarak al
    pipeline.get('rate_limit:total_requests');
    pipeline.get('rate_limit:blocked_requests');
    pipeline.zrange('rate_limit:peak_requests', 0, -1);
    
    const results = await pipeline.exec();
    return this.processMetrics(results);
  }
  
  async alertOnAnomaly(metrics: RateLimitMetrics): Promise<void> {
    if (metrics.rateLimitedRequests / metrics.totalRequests > 0.1) {
      await this.sendAlert('High rate limiting detected', metrics);
    }
  }
}
```

### ğŸ”§ Faz 5: Otomatik Optimizasyon (3-4 Hafta)

#### 5.1 Machine Learning ile Limit Optimizasyonu
```typescript
class AdaptiveRateLimiter {
  private mlModel: RateLimitMLModel;
  
  async optimizeLimits(restaurantId: string): Promise<void> {
    const historicalData = await this.getHistoricalData(restaurantId);
    const prediction = await this.mlModel.predict(historicalData);
    
    const newLimits = {
      menu: prediction.expectedMenuViews * 1.2, // %20 buffer
      order: prediction.expectedOrders * 1.1
    };
    
    await this.updateRestaurantLimits(restaurantId, newLimits);
  }
}
```

#### 5.2 A/B Testing Rate Limits
```typescript
class RateLimitABTest {
  async runABTest(
    restaurantId: string,
    variantA: RateLimitConfig,
    variantB: RateLimitConfig
  ): Promise<ABTestResult> {
    const users = await this.getRestaurantUsers(restaurantId);
    
    // KullanÄ±cÄ±larÄ± gruplara ayÄ±r
    const groupA = users.slice(0, Math.floor(users.length / 2));
    const groupB = users.slice(Math.floor(users.length / 2));
    
    // Her grup iÃ§in farklÄ± limitler uygula
    await this.applyLimits(groupA, variantA);
    await this.applyLimits(groupB, variantB);
    
    // SonuÃ§larÄ± Ã¶lÃ§
    return await this.measureResults(groupA, groupB);
  }
}
```

## ğŸ› ï¸ Implementasyon Ã–ncelikleri

### ğŸ”¥ Acil (Bu Hafta)
1. âœ… **Menu limit'ini 5000'e Ã§Ä±kar** - TamamlandÄ±
2. **Restoran bazlÄ± limit sistemi** - Temel altyapÄ±
3. **Rate limit monitoring** - Dashboard

### ğŸ“ˆ KÄ±sa Vadeli (1-2 Ay)
1. **Token Bucket algoritmasÄ±** - Daha iyi burst handling
2. **Premium kullanÄ±cÄ± sistemi** - Gelir modeli
3. **Distributed rate limiting** - Ã–lÃ§eklenebilirlik

### ğŸš€ Uzun Vadeli (3-6 Ay)
1. **ML tabanlÄ± optimizasyon** - Otomatik ayarlama
2. **A/B testing sistemi** - Veri odaklÄ± kararlar
3. **Global CDN rate limiting** - Edge'de koruma

## ğŸ“‹ Teknik BorÃ§ ve Riskler

### âš ï¸ Mevcut Riskler
1. âœ… **Redis baÄŸlantÄ± sorunlarÄ±** - Ã‡Ã¶zÃ¼ldÃ¼ (Redis Cloud baÄŸlantÄ±sÄ± aktif)
2. **Sabit limitler** - Ã–lÃ§eklenebilirlik sorunu (menu limit'i artÄ±rÄ±ldÄ±)
3. **Monitoring eksikliÄŸi** - Problem tespiti zor

### ğŸ”§ Ã‡Ã¶zÃ¼m PlanÄ±
1. âœ… **Redis Cloud baÄŸlantÄ±sÄ±nÄ± dÃ¼zelt** - TamamlandÄ±
2. **Rate limit dashboard'u ekle** - Ã–ncelik 1
3. **Dinamik limit sistemi** - Ã–ncelik 2

## ğŸ’° Maliyet Analizi

### Redis Cloud Maliyeti
- **Mevcut:** ~$15/ay (1GB RAM)
- **Tahmini:** ~$50/ay (5GB RAM + Cluster)
- **ROI:** Rate limiting sayesinde server maliyetlerinde %70 azalma

### GeliÅŸtirme Maliyeti
- **Faz 1-2:** 3-4 hafta (1 geliÅŸtirici)
- **Faz 3-4:** 4-5 hafta (1 geliÅŸtirici + 0.5 DevOps)
- **Faz 5:** 6-8 hafta (1 geliÅŸtirici + 0.5 Data Scientist)

## ğŸ¯ BaÅŸarÄ± Metrikleri

### ğŸ“Š KPI'lar
1. **Rate limit aÅŸÄ±m oranÄ±:** < %5
2. **API response time:** < 200ms
3. **System uptime:** > 99.9%
4. **User satisfaction:** > 4.5/5

### ğŸ“ˆ Monitoring Dashboard
```typescript
interface RateLimitDashboard {
  realTimeMetrics: {
    requestsPerSecond: number;
    rateLimitedRequests: number;
    averageResponseTime: number;
  };
  topEndpoints: Array<{
    endpoint: string;
    requests: number;
    rateLimited: number;
  }>;
  alerts: Array<{
    type: 'high_rate_limit' | 'anomaly' | 'error';
    message: string;
    timestamp: Date;
  }>;
}
```

## ğŸ”„ Sonraki AdÄ±mlar

1. **Redis baÄŸlantÄ± sorununu Ã§Ã¶z** - Kritik
2. **Menu limit'ini artÄ±r** - Acil
3. **Rate limit dashboard'u oluÅŸtur** - Orta vadeli
4. **Dinamik limit sistemi** - Uzun vadeli

Bu plan ile YemekZen, bÃ¼yÃ¼k restoranlar ve yÃ¼ksek trafikli etkinlikler iÃ§in hazÄ±r hale gelecek. ğŸš€ 