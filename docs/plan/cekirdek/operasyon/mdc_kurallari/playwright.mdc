---
description: This rule enforces best practices and coding standards for Playwright tests, including stable selectors, test isolation, user-centric testing, and performance considerations.
globs: *.spec.ts
---

- **General Principles**
  - **Test User-Visible Behavior:** Focus tests on how users interact with your application, not on internal implementation details.
  - **Isolate Tests:** Ensure tests are independent of each other to prevent cascading failures and ensure predictable results.
  - **Avoid Testing Third-Party Dependencies:** Mock or stub external services and APIs to isolate your application's behavior.

- **Code Organization and Structure**
  - **Directory Structure:**
    - `tests/`: Contains all test files.
    - `tests/e2e/`: End-to-end tests.
    - `tests/unit/`: Unit tests (if applicable, though Playwright is primarily for E2E).
    - `tests/utils/`: Helper functions and page object models.
  - **File Naming Conventions:**
    - Use `.spec.ts` or `.spec.js` for test files (e.g., `login.spec.ts`).
    - Group related tests in the same file.
  - **Module Organization:**
    - Employ Page Object Model (POM) to encapsulate UI elements and interactions.
  - **Component Architecture:**
    - Structure tests around components or features of your application.
  - **Code Splitting Strategies:**
    - Not directly applicable to tests, but keep test files concise and focused.

- **Common Patterns and Anti-patterns**
  - **Design Patterns:**
    - **Page Object Model (POM):** A common pattern where each page is represented as a class, with methods for interacting with the page's elements.  This improves reusability and maintainability. Example:
      typescript
      class LoginPage {
        constructor(private readonly page: Page) {}

        async goto() {
          await this.page.goto('/login');
        }

        async login(username: string, password: string) {
          await this.page.fill('#username', username);
          await this.page.fill('#password', password);
          await this.page.click('#login-button');
        }

        async getErrorMessage() {
          return await this.page.textContent('#error-message');
        }
      }
      
    - **Fixture pattern:** Use Playwright's built-in fixtures to manage test setup and teardown. This ensures each test starts in a clean state.
  - **Recommended Approaches:**
    - Use `baseURL` in `playwright.config.ts` to avoid hardcoding URLs in tests.
    - Utilize `expect` matchers for assertions (e.g., `expect(page.locator('#success')).toBeVisible()`).
    - Use auto-waiting features for improved stability.
  - **Anti-patterns:**
    - Hardcoding URLs.
    - Using brittle selectors (e.g., XPath based on DOM structure).
    - Writing tests that depend on each other.
  - **State Management:**
    - Keep tests stateless. Reset the application state before each test.
    - Use database transactions or API calls to seed data for tests.
  - **Error Handling:**
    - Use `try...catch` blocks to handle expected errors.
    - Log errors and failures with descriptive messages.
    - Use `expect.soft()` for non-critical assertions that shouldn't fail the test immediately.

- **Performance Considerations**
  - **Optimization Techniques:**
    - Run tests in parallel to reduce overall test execution time.
    - Use `reuseExistingServer: true` in `playwright.config.ts` during development to speed up debugging.
    - Use `codegen` to generate selectors automatically.
  - **Memory Management:**
    - Close pages and browsers after each test or group of tests to release resources.
  - **Rendering Optimization:**
    - Not directly applicable but optimize your application's rendering for faster testing.
  - **Bundle Size Optimization:**
    - Not directly applicable, but optimize your application's bundle size for faster loading.
  - **Lazy Loading Strategies:**
    - Not directly applicable to tests.

- **Security Best Practices**
  - **Common Vulnerabilities:**
    - Avoid exposing sensitive data (e.g., passwords, API keys) in test code or logs.
  - **Input Validation:**
    - Test input validation to ensure your application handles invalid data correctly.
  - **Authentication and Authorization:**
    - Test different user roles and permissions.
  - **Data Protection:**
    - Ensure sensitive data is encrypted in the database.
  - **Secure API Communication:**
    - Test that API calls are made over HTTPS.

- **Testing Approaches**
  - **Unit Testing:**
    - While Playwright primarily focuses on E2E testing, unit tests can be written for utility functions or components.
  - **Integration Testing:**
    - Test the interaction between different parts of your application.
  - **End-to-End Testing:**
    - Simulate user flows to test the entire application.
  - **Test Organization:**
    - Group tests by feature or functionality.
    - Use `describe` blocks to organize tests.
  - **Ağ Kontrolü ve Stratejik API Simülasyonu:**
    - **Backend Mantığını Bypass Etme Yasağı:** `page.route` kullanırken asla backend iş mantığını atlamayın. Bu sadece üç onaylanmış amaç için kullanılır:
      1. **Hata Durumlarını Test Etmek:** API'nin 500, 404, timeout gibi hataları nasıl handle ettiğini test etmek
      2. **Veritabanında Hazırlanması Zor Uç Durumları Test Etmek:** Finansal hesaplamalar, karmaşık veri yapıları gibi test ortamında oluşturması zor senaryolar
      3. **Gereksiz Dış Servisleri Engelleyerek Testleri Hızlandırmak:** Analytics, tracking, third-party widgets gibi test için gerekli olmayan servisler
    - **Örnek Kullanım:**
      ```typescript
      // ✅ Good - Hata durumunu test etmek
      await page.route('**/api/payment', route => {
        route.fulfill({ status: 500, body: '{"error": "Payment failed"}' });
      });

      // ✅ Good - Karmaşık finansal hesaplamayı test etmek
      await page.route('**/api/calculate-tax', route => {
        route.fulfill({ 
          status: 200, 
          body: '{"tax": 150.75, "breakdown": {"federal": 100, "state": 50.75}}' 
        });
      });

      // ❌ Bad - Backend mantığını bypass etmek
      await page.route('**/api/validate-user', route => {
        route.fulfill({ status: 200, body: '{"valid": true}' }); // Backend validasyonunu atlıyor
      });
      ```

- **Common Pitfalls and Gotchas**
  - **Frequent Mistakes:**
    - Using XPath instead of CSS selectors.
    - Not using auto-waiting features.
    - Writing flaky tests.
  - **Edge Cases:**
    - Handling different screen sizes and devices.
    - Testing error conditions and edge cases.
  - **Version-Specific Issues:**
    - Stay up-to-date with Playwright's release notes and upgrade guides.
  - **Compatibility Concerns:**
    - **Uyumluluk ve Çapraz Cihaz Testi (projects):** Playwright'ın `projects` özelliğini kullanarak farklı tarayıcı ve cihazlarda otomatik test yapın:
      ```typescript
      // playwright.config.ts
      export default defineConfig({
        projects: [
          {
            name: 'chromium',
            use: { ...devices['Desktop Chrome'] },
          },
          {
            name: 'firefox',
            use: { ...devices['Desktop Firefox'] },
          },
          {
            name: 'webkit',
            use: { ...devices['Desktop Safari'] },
          },
          {
            name: 'Mobile Chrome',
            use: { ...devices['Pixel 5'] },
          },
          {
            name: 'Mobile Safari',
            use: { ...devices['iPhone 12'] },
          },
        ],
      });
      ```
  - **Debugging Strategies:**
    - **Öncelik 1: Trace Viewer:** CI/CD'de bir test başarısız olursa, ilk olarak Trace Viewer dosyasını açın. Bu, testin tam olarak nerede ve neden başarısız olduğunu gösterir:
      ```typescript
      // playwright.config.ts
      use: {
        trace: 'on-first-retry', // Başarısız testler için otomatik trace
        video: 'on',
        screenshot: 'only-on-failure',
      }
      ```
    - **Öncelik 2: Playwright Inspector:** Geliştirme sırasında görsel hata ayıklama için kullanın
    - **Öncelik 3: Console Logging:** `console.log` ile test akışını takip edin
    - **Öncelik 4: Pause Debugging:** `pause()` ile testi durdurup sayfayı inceleyin

- **Tooling and Environment**
  - **Recommended Development Tools:**
    - VS Code with the Playwright extension.
  - **Build Configuration:**
    - Use TypeScript for type safety and autocompletion.
  - **Linting and Formatting:**
    - Use ESLint and Prettier to enforce code style.
  - **Deployment Best Practices:**
    - Run tests in CI/CD pipeline before deploying to production.
  - **CI/CD Integration:**
    - Integrate Playwright with CI/CD tools like GitHub Actions, Jenkins, or GitLab CI.

- **Specific Best Practices & Details**
    - **Stable Selectors:** Prefer CSS selectors based on attributes like `data-testid` or `data-test-id` over XPath or fragile CSS classnames.
    - **Leverage Auto-waiting:** Playwright automatically waits for elements to be actionable before performing actions.  Avoid explicit waits where possible. However, use explicit waits (e.g. `waitForSelector`) when necessary.
    - **Web-First Assertions:** Use `expect` assertions, which retry and wait for conditions to be met. They help to avoid flakiness.
    - **Configure Debugging Highlights:**  Configure `playwright.config.ts` to highlight actions performed by playwright in the browser during debugging to see what's happening step by step. Example:
        typescript
        use: {
            /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
            trace: 'on-first-retry',
            video: 'on',
            screenshot: 'only-on-failure',
        }
        

- **Additional Notes**
    - Regularly review and update your test suite to reflect changes in your application.
    - Document your tests to make them easier to understand and maintain.
    - Use a consistent naming convention for your tests.

## Why Is It Mandatory?

**"Varlıksal İnşa Manifestosu"nun son katmanı, tüm sistemin bir bütün olarak çalıştığını ispatlamak.** Bunu yapmanın tek yolu, gerçek bir tarayıcıda kullanıcı yolculuklarını simüle eden **Uçtan Uca (E2E) Testlerdir**. Bu testler, *"benim makinemde çalışıyordu"* mazeretini tamamen ortadan kaldıran **nihai kanıttır**.

## What Should It Include?

### Kimlik Doğrulama Stratejisi ("Login Once, Run Everywhere")
- **Zorunlu Kural:** Her testte tekrar login olma alışkanlığını tamamen yasaklayın. Bu, testlerin yavaş ve güvenilmez olmasının 1 numaralı sebebidir.
- **"Bir Kez Giriş Yap, Durumu Kaydet ve Tüm Testlerde Kullan" Felsefesi:**
  ```typescript
  // ✅ Good - Global auth state kullanımı
  // tests/auth.setup.ts
  import { test as setup } from '@playwright/test';
  
  setup('authenticate', async ({ page }) => {
    await page.goto('/login');
    await page.fill('[data-testid="email"]', 'test@example.com');
    await page.fill('[data-testid="password"]', 'password');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('/dashboard');
    
    // Auth state'i kaydet
    await page.context().storageState({ path: 'playwright/.auth/user.json' });
  });

  // Her test dosyasında
  test.use({ storageState: 'playwright/.auth/user.json' });
  
  test('should access protected page', async ({ page }) => {
    await page.goto('/admin'); // Otomatik olarak giriş yapılmış durumda
    // Test logic...
  });
  ```

- **Farklı Kullanıcı Rolleri İçin:**
  ```typescript
  // playwright.config.ts
  projects: [
    {
      name: 'setup-admin',
      testMatch: /.*\.setup\.ts/,
    },
    {
      name: 'setup-user',
      testMatch: /.*\.setup\.ts/,
    },
    {
      name: 'chromium-admin',
      dependencies: ['setup-admin'],
      use: { 
        ...devices['Desktop Chrome'],
        storageState: 'playwright/.auth/admin.json',
      },
    },
    {
      name: 'chromium-user',
      dependencies: ['setup-user'],
      use: { 
        ...devices['Desktop Chrome'],
        storageState: 'playwright/.auth/user.json',
      },
    },
  ]
  ```

### Selector Strategy
- **Use test-specific selectors:** Always use `data-testid` or `data-test-id` attributes for test selectors
- **Avoid fragile selectors:** Never rely on CSS classes or DOM structure that can change
- **Prefer semantic selectors:** Use `role`, `name`, or `label` attributes when possible
- **Example selector strategy:**
  ```typescript
  // ✅ Good - Stable and test-specific
  await page.locator('[data-testid="login-button"]').click();
  await page.locator('[data-testid="email-input"]').fill('user@example.com');
  
  // ❌ Bad - Fragile and implementation-dependent
  await page.locator('.btn-primary').click();
  await page.locator('input[type="email"]').fill('user@example.com');
  ```

### Waiting Strategy
- **Ban fixed waits:** Never use `waitForTimeout()` or `page.waitForTimeout()`
- **Use event-based waits:** Prefer `waitForSelector()`, `waitForResponse()`, or `waitForLoadState()`
- **Leverage auto-waiting:** Playwright automatically waits for elements to be actionable
- **Example waiting patterns:**
  ```typescript
  // ✅ Good - Event-based waiting
  await page.waitForSelector('[data-testid="success-message"]');
  await page.waitForResponse(response => response.url().includes('/api/login'));
  
  // ❌ Bad - Fixed timeouts
  await page.waitForTimeout(2000); // Never do this
  ```

### Page Object Model (POM)
- **Separate test logic from selectors:** Create page objects that encapsulate UI interactions
- **Improve maintainability:** Centralize selectors and interactions in reusable classes
- **Example POM implementation:**
  ```typescript
  class LoginPage {
    constructor(private page: Page) {}
    
    // Encapsulate selectors
    private get emailInput() { return this.page.locator('[data-testid="email-input"]'); }
    private get passwordInput() { return this.page.locator('[data-testid="password-input"]'); }
    private get loginButton() { return this.page.locator('[data-testid="login-button"]'); }
    
    // Encapsulate interactions
    async login(email: string, password: string) {
      await this.emailInput.fill(email);
      await this.passwordInput.fill(password);
      await this.loginButton.click();
    }
    
    async waitForLoginSuccess() {
      await this.page.waitForSelector('[data-testid="dashboard"]');
    }
  }
  ```

### Test Data Management
- **Ensure clean state:** Each test should start with a predictable, clean database state
- **Use database seed/teardown:** Call database setup scripts before each test
- **Isolate test data:** Use unique identifiers to prevent test interference
- **Example test data setup:**
  ```typescript
  test.beforeEach(async ({ page }) => {
    // Setup test data
    await seedTestDatabase();
    await createTestUser({ email: 'test@example.com', password: 'password' });
  });
  
  test.afterEach(async () => {
    // Clean up test data
    await cleanupTestDatabase();
  });
  ```

### "BugBot Mode" - Proactive Testing Questions
- **Cross-device compatibility:** "Does this test work on different screen resolutions (mobile, tablet)?"
- **Network conditions:** "How does it behave with slow network connections?"
- **Browser compatibility:** "Does this test pass on all target browsers (Chrome, Firefox, Safari)?"
- **Accessibility:** "Can this functionality be used with screen readers and keyboard navigation?"
- **Error scenarios:** "What happens when the API returns an error or the page fails to load?"
- **Performance:** "Does the page load within acceptable time limits?"
- **State persistence:** "Does the test handle page refreshes and browser back/forward navigation?"
- **Concurrent users:** "What happens if multiple users perform the same action simultaneously?"
- **Data validation:** "Are form validations working correctly for edge cases?"
- **Security:** "Are sensitive operations properly protected and logged?"
- **Data validation:** "Are form validations working correctly for edge cases?"
- **Security:** "Are sensitive operations properly protected and logged?"