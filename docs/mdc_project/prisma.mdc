---
description: Enforces Prisma best practices as the core of our "Database-First" principle. It governs schema design, type-safe data access, and secure database interactions, acting as the bridge between our SQL schema and TypeScript code.
globs: *.prisma
---

# Rule Set: Prisma - The Database-First Engine

## 0. Database Access Hierarchy Rule - Constitutional Authority
**Default Rule:** All CRUD (Create, Read, Update, Delete) operations and simple relational queries MUST use Prisma Client. This ensures type safety and SQL injection protection.

**Database Hosting:** The PostgreSQL database is hosted by Supabase, but all database operations are performed through Prisma ORM.

**Exception Rule (Raw SQL):** Raw SQL via `prisma.$queryRaw` is ONLY permitted for:
- Complex reporting queries that exceed Prisma's capabilities
- PostgreSQL-specific features (e.g., PostGIS)
- Extreme performance optimization scenarios requiring custom SQL

**Requirement:** Any raw SQL usage MUST be justified with a code comment explaining why Prisma Client is insufficient, and all parameters MUST be safely passed using parameterized queries.

## 1. Core Directives for the AI Agent
- **Directive 1 (Schema is the Single Source of Truth):** The `schema.prisma` file is the ultimate definition of our data models and their relationships. All application code (repositories, services) MUST be derived from the types generated by this schema. If the code needs a different data shape, the `schema.prisma` must be changed first, and then a migration must be run.
- **Directive 2 (The Law of the Generated Client):** You MUST NOT write raw SQL queries for standard CRUD operations. You must use the generated Prisma Client (`prisma.user.findUnique`, `prisma.order.create`, etc.). Raw SQL (`$queryRaw`) is only permissible for complex queries that cannot be expressed with the Prisma API, and its use requires explicit justification in a comment.
- **Directive 3 (Migration Before Code):** Before writing any code that uses a new or modified data model, you MUST first create a database migration with `prisma migrate dev`. This ensures the database is always in sync with the schema definition.

## 2. Unbreakable Architectural Constitution
- **Rule 2.1 (Centralized Client Instance):** The Prisma Client MUST be instantiated once and exported from a single file (e.g., `/lib/prisma.ts`). Creating multiple instances will exhaust database connections.
- **Rule 2.2 (Abstraction is Mandatory):** The Prisma Client (`prisma`) MUST NOT be imported or used directly within API Routes or Frontend Components. All database interactions MUST be encapsulated within a dedicated repository or service layer. This enforces the Katmanlı Mimari Zorunluluğu (Mandatory Layered Architecture).
- **Rule 2.3 (Implicit Transaction Prohibition):** For any operation involving more than one write to the database (e.g., creating an `Order` and updating `Inventory`), you MUST use the interactive transactions API (`prisma.$transaction([])`). Relying on individual, implicit transactions for related operations is a data integrity violation.

## 3. Integrated Security Fabric
- **Rule 3.1 (Row-Level Security (RLS) is the Standard):** For our multi-tenant application, PostgreSQL's Row-Level Security MUST be enabled. The `schema.prisma` should include comments indicating which tables are protected by RLS policies. The Prisma Client will be instantiated in a way that passes user context (like `tenant_id`) to the database to enforce these policies.
- **Rule 3.2 (Preventing Data Exposure):** When querying data, ALWAYS use `select` or `include` to explicitly define the fields you need. A query without `select` or `include` can accidentally expose sensitive fields like `password_hash` if they are added to the model later.
- **Rule 3.3 (Input Validation Before Query):** All data passed to Prisma Client methods (e.g., in a `where` or `data` clause) MUST be validated by a schema library like `Zod` *before* the call is made.

## 4. Proactive Quality & Optimization Protocol (BugBot Mode)
- **Performance Analysis:**
    - **N+1 Query Detection:** "Am I fetching a list of items (e.g., users) and then, inside a loop, fetching a related item for each (e.g., their latest order)? This is a classic N+1 problem. Refactor this to use a single query with an `include` clause or a separate, bulk query for the related items."
    - **Indexing Check:** "Does this query filter (`where`) or sort (`orderBy`) by a column that is not indexed? Check the `schema.prisma` for an `@index` or `@@index` attribute. If it's missing, this will be slow on large tables. Propose adding an index via a new migration."
- **Code Smell Detection:**
    - **Leaking the Prisma Client:** "Is the `prisma` client instance being exported from a file that is used by frontend components? This is a critical security risk. The client must only be accessible on the server."
    - **Complex Logic in Queries:** "Is there complex business logic (e.g., multi-step calculations) inside a Prisma query? Refactor this logic into the service layer, keeping the database query focused on data retrieval."
- **Automated Refactoring Suggestion:** If a query is found that selects a `user` model without explicitly excluding the `password_hash`, propose a refactoring that uses a `select` clause to pick only the necessary fields, or suggest creating a reusable repository function that always excludes sensitive fields.